# Comparisons

The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don't want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.

### Metrics

- Client storage
- Client computation
- Online communication
- Offline communication (if any)
- Server storage
- Server computation
- Ability to support multiple clients

---

### Notations:

$m$: the number of key-value pairs.

$k$: normally this stands for a key in one key-value pair. 

DB: database in the server.

$N$: the number of entries in the database. This is not $m$.

---

Let's start by investigating how they realize the keyword PIR feature. 

### Cuckoo Hashing based on Onion

The paper [Communication--Computation Trade-offs in PIR](https://eprint.iacr.org/2019/1483) brought up a very simple method for realizing the keyword support. 

Server initialize 2 cuckoo hash table defined by 2 hash functions $\mathrm{H}_1, \mathrm{H}_2$ and insert all the key-value pairs. This introduces $N = 2m$. Suppose 

After the database is configured, the client can use $\mathrm{H_1, H_2}$ to calculate the hash for the two positions. This is fast and easy. Then client initiates two PIR queries to get the two indices.

- Client storage
  - $O(1)$ for $\mathrm{H_1, H_2}$ + storage for PIR scheme. This is small
- Client computation.
  - $O(1)$ for computing $\mathrm{H_1, H_2}$ + computation for PIR scheme.
- Online communication
  - 2 PIR queries.
- Offline communication (if any)
  - None if in stateless PIR scheme.
- Server storage
  - $N = 2m \approx $ twice as large as the PIR scheme it uses.
- Server computation
  - Since $N = 2m$, this is also $\approx$ twice larger than a normal PIR scheme if we run the black box twice.
- Ability to support multiple clients
  - Very easy. The server can share the two hash functions $\mathrm{H_1, H_2}$ to the public for client to download. The database is fixed.

#### Advantage: 

This scheme works for all index-based PIR schemes. Both stateful and stateless. This completely uses PIR as a black box that stores the cuckoo hashing table as data.

#### Disadvantage: 

Twice slower than the normal index-based PIR scheme. 



### SparsePIR based on Onion 

TODO:

### ChalametPIR Using Key-value Filter

The server uses 4 hash functions to store $m$ key-value pairs in $N = รง m = 1.13m$ entries. The hash functions are randomly generated by ther server. The server uses these 4 hash functions to generate the database. The performance depends on the Binary Fuse Filter (BFF). In the query state, the client uses the 4 hash functions to compute $\mathrm{H_1(k), H_2(k), H_3(k), H_4(k)}$ and does one of the the followings: 
$$
\begin{cases}
\text{In FrodoPIR, put all 4 indices into one query. Server does LWE multiplication.}\\
\\
\text{Naive: perform 4 index-based PIR queries.}
\end{cases}
$$


- Client storage
  - $O(1)$ many hashes.
- Client computation
- Online communication
- Offline communication (if any)
- Server storage
- Server computation
- Ability to support multiple clients

















