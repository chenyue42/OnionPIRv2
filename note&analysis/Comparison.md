# Comparisons

The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don't want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.

### Metrics

- Client storage
- Client computation
- Online communication
- Offline communication (if any)
- Server storage
- Server computation
- Ability to support multiple clients

---

### Notations:

$m$: the number of key-value pairs.

$k$: normally this stands for a key in one key-value pair. 

DB: database in the server.

$N$: the number of entries in the database. This is not $m$.

---
## Choice of filters

Paper: [Binary Fuse Filters: Fast and Smaller Than Xor Filters](https://arxiv.org/pdf/2201.01174).

### Cuckoo hashing

- Storage space
  - range from 30 to 40% of the theoretial lower bound
- Query(computation) time
  - almost the same as 4-wise BF
- Construction time
  - Close to XOR filter almost times compared to BF

### Binary fuse filter

- Storage space
  - 3-wise BF: 13% of the theoretial lower bound
  - 4-wise BF: 8% of the theoretial lower bound
- Query(computation) time
  - 3-wise BF: Slightly better than 4-wise BF, almost the same as XOR filter
  - 4-wise BF: Slightly worse than 3-wise BF, almost the same as Cuckoo hashing
- Construction time
  - 3-wise BF: Slightly worse than 4-wise BF
  - 4-wise BF: Slightly better than 3-wise BF


Notes:
- BF filter are generally much superior than cuckoo hashing except the query time is very close to 4-wise BF.
- 3-wise BF takes up more storage to trade for faster query response, compared to 4-wise BF.

TODO: Check out [Ribbon filter](https://arxiv.org/pdf/2103.02515). It is also better than Cuckoo hashing and XOR filter. In this paper it is claimed that binary fuse is better than Ribbon. Is it so? Is it suitable to our scheme (stateful and stateless)? 


Let's start by investigating how they realize the keyword PIR feature. 

---

### Cuckoo Hashing based on Onion

The paper [Communication--Computation Trade-offs in PIR](https://eprint.iacr.org/2019/1483) brought up a very simple method for realizing the keyword support. 

Server initialize 2 cuckoo hash table defined by 2 hash functions $\mathrm{H}_1, \mathrm{H}_2$ and insert all the key-value pairs. This introduces $N = 2m$. Suppose 

After the database is configured, the client can use $\mathrm{H_1, H_2}$ to calculate the hash for the two positions. This is fast and easy. Then client initiates two PIR queries to get the two indices.

- Client storage
  - $O(1)$ for $\mathrm{H_1, H_2}$ + storage for PIR scheme. This is small
- Client computation.
  - $O(1)$ for computing $\mathrm{H_1, H_2}$ + computation for PIR scheme.
- Online communication
  - 2 PIR queries.
- Download size
  - (?)
- Offline communication (if any)
  - None if in stateless PIR scheme.
- Server storage
  - $N = 2m \approx $ twice as large as the PIR scheme it uses.
- Server computation
  - Since $N = 2m$, this is also $\approx$ twice larger than a normal PIR scheme if we run the black box twice.
- Ability to support multiple clients
  - Very easy. The server can share the two hash functions $\mathrm{H_1, H_2}$ to the public for client to download. The database is fixed.

#### Advantage: 

This scheme works for all index-based PIR schemes. Both stateful and stateless. This completely uses PIR as a black box that stores the cuckoo hashing table as data.

#### Disadvantage: 

Twice slower than the normal index-based PIR scheme. 

### SparsePIR based on Onion 

TODO:

### ChalametPIR Using Key-value Filter

The server uses 4 hash functions to store $m$ key-value pairs in $N = รง m = 1.08m$ entries. The hash functions are randomly generated by ther server. The server uses these 4 hash functions to generate the database. The performance depends on the Binary Fuse Filter (BFF). In the query state, the client uses the 4 hash functions to compute $\mathrm{H_1(k), H_2(k), H_3(k), H_4(k)}$ and does one of the the followings: 
$$
\begin{cases}
\text{In FrodoPIR, put all 4 indices into one query. Server does LWE multiplication.}\\
\\
\text{Naive: perform 4 index-based PIR queries.}
\end{cases}
$$

- Client storage
  - k hash funcitons and (?)
- Client computation
  - negligible query ($O(n)$) and parsing ($O(1)$) time < 1 ms
- Online communication
  - one PIR query
  - ~1 second
- Download size
  - almost the same as Frodo PIR
  - $O(1)$ ~6MB
- Offline communication (if any)
- Server storage
  - $N = รง m = 1.08m$ when $k=4$
- Server computation
  - Slightly slower than the Frodo PIR scheme.
  - O(m) 10e6 seconds for 218 ร 1 kB DB
- Ability to support multiple clients















